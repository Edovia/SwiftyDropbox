
/* Autogenerated. Do not edit. */

import Foundation
/**
    Datatypes and serializers for the files namespace
*/
public class Files {
    /**
        The CommitInfo struct
    */
    public class CommitInfo: CustomStringConvertible {
        /// Path in the user's Dropbox to save the file.
        public let path : String
        /// Selects what to do if the file already exists.
        public let mode : Files.WriteMode
        /// If there's a conflict, as determined by mode, have the Dropbox server try to autorename the file to avoid
        /// conflict.
        public let autorename : Bool
        /// The value to store as the clientModified timestamp. Dropbox automatically records the time at which the file
        /// was written to the Dropbox servers. It can also record an additional timestamp, provided by Dropbox desktop
        /// clients, mobile clients, and API apps of when the file was actually created or modified.
        public let clientModified : Date?
        /// Normally, users are made aware of any file modifications in their Dropbox account via notifications in the
        /// client software. If true, this tells the clients that this modification shouldn't result in a user
        /// notification.
        public let mute : Bool
        public init(path: String, mode: Files.WriteMode = .add, autorename: Bool = false, clientModified: Date? = nil, mute: Bool = false) {
            stringValidator(pattern: "/.*")(path)
            self.path = path
            self.mode = mode
            self.autorename = autorename
            self.clientModified = clientModified
            self.mute = mute
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CommitInfoSerializer().serialize(self)))"
        }
    }
    public class CommitInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CommitInfo) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "mode": Files.WriteModeSerializer().serialize(value.mode),
            "autorename": Serialization._BoolSerializer.serialize(value.autorename),
            "client_modified": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.clientModified),
            "mute": Serialization._BoolSerializer.serialize(value.mute),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> CommitInfo {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let mode = Files.WriteModeSerializer().deserialize(dict["mode"] ?? .null)
                    let autorename = Serialization._BoolSerializer.deserialize(dict["autorename"] ?? .null)
                    let clientModified = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["client_modified"] ?? .null)
                    let mute = Serialization._BoolSerializer.deserialize(dict["mute"] ?? .null)
                    return CommitInfo(path: path, mode: mode, autorename: autorename, clientModified: clientModified, mute: mute)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The CreateFolderArg struct
    */
    public class CreateFolderArg: CustomStringConvertible {
        /// Path in the user's Dropbox to create.
        public let path : String
        public init(path: String) {
            stringValidator(pattern: "/.*")(path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderArgSerializer().serialize(self)))"
        }
    }
    public class CreateFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CreateFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> CreateFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return CreateFolderArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The CreateFolderError union
    */
    public enum CreateFolderError: CustomStringConvertible {
        case path(Files.WriteError)
        public var description : String {
            return "\(prepareJSONForSerialization(CreateFolderErrorSerializer().serialize(self)))"
        }
    }
    public class CreateFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: CreateFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> CreateFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return CreateFolderError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The DeleteArg struct
    */
    public class DeleteArg: CustomStringConvertible {
        /// Path in the user's Dropbox to delete.
        public let path : String
        public init(path: String) {
            stringValidator(pattern: "/.*")(path)
            self.path = path
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteArgSerializer().serialize(self)))"
        }
    }
    public class DeleteArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DeleteArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> DeleteArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    return DeleteArg(path: path)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The DeleteError union
    */
    public enum DeleteError: CustomStringConvertible {
        case pathLookup(Files.LookupError)
        case pathWrite(Files.WriteError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(DeleteErrorSerializer().serialize(self)))"
        }
    }
    public class DeleteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DeleteError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> DeleteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return DeleteError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return DeleteError.pathWrite(v)
                        case "other":
                            return DeleteError.other
                        default:
                            return DeleteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Metadata for a file or folder.
    */
    public class Metadata: CustomStringConvertible {
        /// The last component of the path (including extension). This never contains a slash.
        public let name : String
        /// The lowercased full path in the user's Dropbox. This always starts with a slash.
        public let pathLower : String
        /// Deprecated. Please use :field:'FileSharingInfo.parent_shared_folder_id' or
        /// :field:'FolderSharingInfo.parent_shared_folder_id' instead.
        public let parentSharedFolderId : String?
        public init(name: String, pathLower: String, parentSharedFolderId: String? = nil) {
            stringValidator()(name)
            self.name = name
            stringValidator()(pathLower)
            self.pathLower = pathLower
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MetadataSerializer().serialize(self)))"
        }
    }
    public class MetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: Metadata) -> JSON {
            var output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            switch value {
                case let file as Files.FileMetadata:
                    for (k,v) in Serialization.getFields(Files.FileMetadataSerializer().serialize(file)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("file")
                case let folder as Files.FolderMetadata:
                    for (k,v) in Serialization.getFields(Files.FolderMetadataSerializer().serialize(folder)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("folder")
                case let deleted as Files.DeletedMetadata:
                    for (k,v) in Serialization.getFields(Files.DeletedMetadataSerializer().serialize(deleted)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("deleted")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> Metadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "file":
                            return Files.FileMetadataSerializer().deserialize(json)
                        case "folder":
                            return Files.FolderMetadataSerializer().deserialize(json)
                        case "deleted":
                            return Files.DeletedMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Indicates that there used to be a file or folder at this path, but it no longer exists.
    */
    public class DeletedMetadata: Files.Metadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(DeletedMetadataSerializer().serialize(self)))"
        }
    }
    public class DeletedMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DeletedMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> DeletedMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    return DeletedMetadata(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Dimensions for a photo or video.
    */
    public class Dimensions: CustomStringConvertible {
        /// Height of the photo/video.
        public let height : UInt64
        /// Width of the photo/video.
        public let width : UInt64
        public init(height: UInt64, width: UInt64) {
            comparableValidator()(height)
            self.height = height
            comparableValidator()(width)
            self.width = width
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DimensionsSerializer().serialize(self)))"
        }
    }
    public class DimensionsSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: Dimensions) -> JSON {
            let output = [ 
            "height": Serialization._UInt64Serializer.serialize(value.height),
            "width": Serialization._UInt64Serializer.serialize(value.width),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> Dimensions {
            switch json {
                case .dictionary(let dict):
                    let height = Serialization._UInt64Serializer.deserialize(dict["height"] ?? .null)
                    let width = Serialization._UInt64Serializer.deserialize(dict["width"] ?? .null)
                    return Dimensions(height: height, width: width)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The DownloadArg struct
    */
    public class DownloadArg: CustomStringConvertible {
        /// The path of the file to download.
        public let path : String
        /// Deprecated. Please specify revision in :field:'path' instead
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadArgSerializer().serialize(self)))"
        }
    }
    public class DownloadArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DownloadArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> DownloadArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return DownloadArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The DownloadError union
    */
    public enum DownloadError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(DownloadErrorSerializer().serialize(self)))"
        }
    }
    public class DownloadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: DownloadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> DownloadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return DownloadError.path(v)
                        case "other":
                            return DownloadError.other
                        default:
                            return DownloadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The FileMetadata struct
    */
    public class FileMetadata: Files.Metadata {
        /// A unique identifier for the file.
        public let id : String?
        /// For files, this is the modification time set by the desktop client when the file was added to Dropbox. Since
        /// this time is not verified (the Dropbox server stores whatever the desktop client sends up), this should only
        /// be used for display purposes (such as sorting) and not, for example, to determine if a file has changed or
        /// not.
        public let clientModified : Date
        /// The last time the file was modified on Dropbox.
        public let serverModified : Date
        /// A unique identifier for the current revision of a file. This field is the same rev as elsewhere in the API
        /// and can be used to detect changes and avoid conflicts.
        public let rev : String
        /// The file size in bytes.
        public let size : UInt64
        /// Additional information if the file is a photo or video.
        public let mediaInfo : Files.MediaInfo?
        /// Set if this file is contained in a shared folder.
        public let sharingInfo : Files.FileSharingInfo?
        public init(name: String, pathLower: String, clientModified: Date, serverModified: Date, rev: String, size: UInt64, parentSharedFolderId: String? = nil, id: String? = nil, mediaInfo: Files.MediaInfo? = nil, sharingInfo: Files.FileSharingInfo? = nil) {
            nullableValidator(stringValidator(minLength: 1))(id)
            self.id = id
            self.clientModified = clientModified
            self.serverModified = serverModified
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
            comparableValidator()(size)
            self.size = size
            self.mediaInfo = mediaInfo
            self.sharingInfo = sharingInfo
            super.init(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FileMetadataSerializer().serialize(self)))"
        }
    }
    public class FileMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FileMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "client_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.clientModified),
            "server_modified": NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").serialize(value.serverModified),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            "size": Serialization._UInt64Serializer.serialize(value.size),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "media_info": NullableSerializer(Files.MediaInfoSerializer()).serialize(value.mediaInfo),
            "sharing_info": NullableSerializer(Files.FileSharingInfoSerializer()).serialize(value.sharingInfo),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FileMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .null)
                    let clientModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["client_modified"] ?? .null)
                    let serverModified = NSDateSerializer("%Y-%m-%dT%H:%M:%SZ").deserialize(dict["server_modified"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    let size = Serialization._UInt64Serializer.deserialize(dict["size"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let mediaInfo = NullableSerializer(Files.MediaInfoSerializer()).deserialize(dict["media_info"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FileSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    return FileMetadata(name: name, pathLower: pathLower, clientModified: clientModified, serverModified: serverModified, rev: rev, size: size, parentSharedFolderId: parentSharedFolderId, id: id, mediaInfo: mediaInfo, sharingInfo: sharingInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Sharing info for a file or folder.
    */
    public class SharingInfo: CustomStringConvertible {
        /// True if the file or folder is inside a read-only shared folder.
        public let readOnly : Bool
        public init(readOnly: Bool) {
            self.readOnly = readOnly
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SharingInfoSerializer().serialize(self)))"
        }
    }
    public class SharingInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    return SharingInfo(readOnly: readOnly)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Sharing info for a file which is contained by a shared folder.
    */
    public class FileSharingInfo: Files.SharingInfo {
        /// ID of shared folder that holds this file.
        public let parentSharedFolderId : String
        /// The last user who modified the file. This field will be null if the user's account has been deleted.
        public let modifiedBy : String?
        public init(readOnly: Bool, parentSharedFolderId: String, modifiedBy: String? = nil) {
            stringValidator(pattern: "[-_0-9a-zA-Z:]+")(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(minLength: 40, maxLength: 40))(modifiedBy)
            self.modifiedBy = modifiedBy
            super.init(readOnly: readOnly)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FileSharingInfoSerializer().serialize(self)))"
        }
    }
    public class FileSharingInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FileSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": Serialization._StringSerializer.serialize(value.parentSharedFolderId),
            "modified_by": NullableSerializer(Serialization._StringSerializer).serialize(value.modifiedBy),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FileSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = Serialization._StringSerializer.deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let modifiedBy = NullableSerializer(Serialization._StringSerializer).deserialize(dict["modified_by"] ?? .null)
                    return FileSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, modifiedBy: modifiedBy)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The FolderMetadata struct
    */
    public class FolderMetadata: Files.Metadata {
        /// A unique identifier for the folder.
        public let id : String?
        /// Deprecated. Please use :field:'sharing_info' instead.
        public let sharedFolderId : String?
        /// Set if the folder is contained in a shared folder or is a shared folder mount point.
        public let sharingInfo : Files.FolderSharingInfo?
        public init(name: String, pathLower: String, parentSharedFolderId: String? = nil, id: String? = nil, sharedFolderId: String? = nil, sharingInfo: Files.FolderSharingInfo? = nil) {
            nullableValidator(stringValidator(minLength: 1))(id)
            self.id = id
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            self.sharingInfo = sharingInfo
            super.init(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FolderMetadataSerializer().serialize(self)))"
        }
    }
    public class FolderMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FolderMetadata) -> JSON {
            let output = [ 
            "name": Serialization._StringSerializer.serialize(value.name),
            "path_lower": Serialization._StringSerializer.serialize(value.pathLower),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "id": NullableSerializer(Serialization._StringSerializer).serialize(value.id),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            "sharing_info": NullableSerializer(Files.FolderSharingInfoSerializer()).serialize(value.sharingInfo),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FolderMetadata {
            switch json {
                case .dictionary(let dict):
                    let name = Serialization._StringSerializer.deserialize(dict["name"] ?? .null)
                    let pathLower = Serialization._StringSerializer.deserialize(dict["path_lower"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let id = NullableSerializer(Serialization._StringSerializer).deserialize(dict["id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    let sharingInfo = NullableSerializer(Files.FolderSharingInfoSerializer()).deserialize(dict["sharing_info"] ?? .null)
                    return FolderMetadata(name: name, pathLower: pathLower, parentSharedFolderId: parentSharedFolderId, id: id, sharedFolderId: sharedFolderId, sharingInfo: sharingInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Sharing info for a folder which is contained in a shared folder or is a shared folder mount point.
    */
    public class FolderSharingInfo: Files.SharingInfo {
        /// Set if the folder is contained by a shared folder.
        public let parentSharedFolderId : String?
        /// If this folder is a shared folder mount point, the ID of the shared folder mounted at this location.
        public let sharedFolderId : String?
        public init(readOnly: Bool, parentSharedFolderId: String? = nil, sharedFolderId: String? = nil) {
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(parentSharedFolderId)
            self.parentSharedFolderId = parentSharedFolderId
            nullableValidator(stringValidator(pattern: "[-_0-9a-zA-Z:]+"))(sharedFolderId)
            self.sharedFolderId = sharedFolderId
            super.init(readOnly: readOnly)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(FolderSharingInfoSerializer().serialize(self)))"
        }
    }
    public class FolderSharingInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: FolderSharingInfo) -> JSON {
            let output = [ 
            "read_only": Serialization._BoolSerializer.serialize(value.readOnly),
            "parent_shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.parentSharedFolderId),
            "shared_folder_id": NullableSerializer(Serialization._StringSerializer).serialize(value.sharedFolderId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> FolderSharingInfo {
            switch json {
                case .dictionary(let dict):
                    let readOnly = Serialization._BoolSerializer.deserialize(dict["read_only"] ?? .null)
                    let parentSharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["parent_shared_folder_id"] ?? .null)
                    let sharedFolderId = NullableSerializer(Serialization._StringSerializer).deserialize(dict["shared_folder_id"] ?? .null)
                    return FolderSharingInfo(readOnly: readOnly, parentSharedFolderId: parentSharedFolderId, sharedFolderId: sharedFolderId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetMetadataArg struct
    */
    public class GetMetadataArg: CustomStringConvertible {
        /// The path of a file or folder on Dropbox
        public let path : String
        /// If true, :field:'FileMetadata.media_info' is set for photo and video.
        public let includeMediaInfo : Bool
        public init(path: String, includeMediaInfo: Bool = false) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(path)
            self.path = path
            self.includeMediaInfo = includeMediaInfo
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataArgSerializer().serialize(self)))"
        }
    }
    public class GetMetadataArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetMetadataArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GetMetadataArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .null)
                    return GetMetadataArg(path: path, includeMediaInfo: includeMediaInfo)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The GetMetadataError union
    */
    public enum GetMetadataError: CustomStringConvertible {
        case path(Files.LookupError)
        public var description : String {
            return "\(prepareJSONForSerialization(GetMetadataErrorSerializer().serialize(self)))"
        }
    }
    public class GetMetadataErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GetMetadataError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> GetMetadataError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return GetMetadataError.path(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        GPS coordinates for a photo or video.
    */
    public class GpsCoordinates: CustomStringConvertible {
        /// Latitude of the GPS coordinates.
        public let latitude : Double
        /// Longitude of the GPS coordinates.
        public let longitude : Double
        public init(latitude: Double, longitude: Double) {
            comparableValidator()(latitude)
            self.latitude = latitude
            comparableValidator()(longitude)
            self.longitude = longitude
        }
        public var description : String {
            return "\(prepareJSONForSerialization(GpsCoordinatesSerializer().serialize(self)))"
        }
    }
    public class GpsCoordinatesSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: GpsCoordinates) -> JSON {
            let output = [ 
            "latitude": Serialization._DoubleSerializer.serialize(value.latitude),
            "longitude": Serialization._DoubleSerializer.serialize(value.longitude),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> GpsCoordinates {
            switch json {
                case .dictionary(let dict):
                    let latitude = Serialization._DoubleSerializer.deserialize(dict["latitude"] ?? .null)
                    let longitude = Serialization._DoubleSerializer.deserialize(dict["longitude"] ?? .null)
                    return GpsCoordinates(latitude: latitude, longitude: longitude)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderArg struct
    */
    public class ListFolderArg: CustomStringConvertible {
        /// The path to the folder you want to see the contents of.
        public let path : String
        /// If true, the list folder operation will be applied recursively to all subfolders and the response will
        /// contain contents of all subfolders.
        public let recursive : Bool
        /// If true, :field:'FileMetadata.media_info' is set for photo and video.
        public let includeMediaInfo : Bool
        /// If true, the results will include entries for files and folders that used to exist but were deleted.
        public let includeDeleted : Bool
        public init(path: String, recursive: Bool = false, includeMediaInfo: Bool = false, includeDeleted: Bool = false) {
            stringValidator(pattern: "(/.*)?")(path)
            self.path = path
            self.recursive = recursive
            self.includeMediaInfo = includeMediaInfo
            self.includeDeleted = includeDeleted
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "recursive": Serialization._BoolSerializer.serialize(value.recursive),
            "include_media_info": Serialization._BoolSerializer.serialize(value.includeMediaInfo),
            "include_deleted": Serialization._BoolSerializer.serialize(value.includeDeleted),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let recursive = Serialization._BoolSerializer.deserialize(dict["recursive"] ?? .null)
                    let includeMediaInfo = Serialization._BoolSerializer.deserialize(dict["include_media_info"] ?? .null)
                    let includeDeleted = Serialization._BoolSerializer.deserialize(dict["include_deleted"] ?? .null)
                    return ListFolderArg(path: path, recursive: recursive, includeMediaInfo: includeMediaInfo, includeDeleted: includeDeleted)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderContinueArg struct
    */
    public class ListFolderContinueArg: CustomStringConvertible {
        /// The cursor returned by your last call to listFolder or listFolderContinue.
        public let cursor : String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderContinueArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderContinueArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderContinueArg(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderContinueError union
    */
    public enum ListFolderContinueError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        */
        case reset
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderContinueErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderContinueErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderContinueError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .reset:
                    var d = [String : JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListFolderContinueError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderContinueError.path(v)
                        case "reset":
                            return ListFolderContinueError.reset
                        case "other":
                            return ListFolderContinueError.other
                        default:
                            return ListFolderContinueError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListFolderError union
    */
    public enum ListFolderError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListFolderError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListFolderError.path(v)
                        case "other":
                            return ListFolderError.other
                        default:
                            return ListFolderError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListFolderGetLatestCursorResult struct
    */
    public class ListFolderGetLatestCursorResult: CustomStringConvertible {
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor : String
        public init(cursor: String) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderGetLatestCursorResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderGetLatestCursorResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderGetLatestCursorResult) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderGetLatestCursorResult {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    return ListFolderGetLatestCursorResult(cursor: cursor)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderLongpollArg struct
    */
    public class ListFolderLongpollArg: CustomStringConvertible {
        /// A cursor as returned by listFolder or listFolderContinue
        public let cursor : String
        /// A timeout in seconds. The request will block for at most this length of time, plus up to 90 seconds of
        /// random jitter added to avoid the thundering herd problem. Care should be taken when using this parameter, as
        /// some network infrastructure does not support long timeouts.
        public let timeout : UInt64
        public init(cursor: String, timeout: UInt64 = 30) {
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            comparableValidator(minValue: 30, maxValue: 480)(timeout)
            self.timeout = timeout
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollArgSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderLongpollArg) -> JSON {
            let output = [ 
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "timeout": Serialization._UInt64Serializer.serialize(value.timeout),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderLongpollArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let timeout = Serialization._UInt64Serializer.deserialize(dict["timeout"] ?? .null)
                    return ListFolderLongpollArg(cursor: cursor, timeout: timeout)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderLongpollError union
    */
    public enum ListFolderLongpollError: CustomStringConvertible {
        /**
            Indicates that the cursor has been invalidated. Call listFolder to obtain a new cursor.
        */
        case reset
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollErrorSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderLongpollError) -> JSON {
            switch value {
                case .reset:
                    var d = [String : JSON]()
                    d[".tag"] = .str("reset")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListFolderLongpollError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "reset":
                            return ListFolderLongpollError.reset
                        case "other":
                            return ListFolderLongpollError.other
                        default:
                            return ListFolderLongpollError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListFolderLongpollResult struct
    */
    public class ListFolderLongpollResult: CustomStringConvertible {
        /// Indicates whether new changes are available. If true, call listFolder to retrieve the changes.
        public let changes : Bool
        /// If present, backoff for at least this many seconds before calling listFolderLongpoll again.
        public let backoff : UInt64?
        public init(changes: Bool, backoff: UInt64? = nil) {
            self.changes = changes
            nullableValidator(comparableValidator())(backoff)
            self.backoff = backoff
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderLongpollResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderLongpollResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderLongpollResult) -> JSON {
            let output = [ 
            "changes": Serialization._BoolSerializer.serialize(value.changes),
            "backoff": NullableSerializer(Serialization._UInt64Serializer).serialize(value.backoff),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderLongpollResult {
            switch json {
                case .dictionary(let dict):
                    let changes = Serialization._BoolSerializer.deserialize(dict["changes"] ?? .null)
                    let backoff = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["backoff"] ?? .null)
                    return ListFolderLongpollResult(changes: changes, backoff: backoff)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListFolderResult struct
    */
    public class ListFolderResult: CustomStringConvertible {
        /// The files and (direct) subfolders in the folder.
        public let entries : Array<Files.Metadata>
        /// Pass the cursor into listFolderContinue to see what's changed in the folder since your previous query.
        public let cursor : String
        /// If true, then there are more entries available. Pass the cursor to listFolderContinue to retrieve the rest.
        public let hasMore : Bool
        public init(entries: Array<Files.Metadata>, cursor: String, hasMore: Bool) {
            self.entries = entries
            stringValidator(minLength: 1)(cursor)
            self.cursor = cursor
            self.hasMore = hasMore
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListFolderResultSerializer().serialize(self)))"
        }
    }
    public class ListFolderResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListFolderResult) -> JSON {
            let output = [ 
            "entries": ArraySerializer(Files.MetadataSerializer()).serialize(value.entries),
            "cursor": Serialization._StringSerializer.serialize(value.cursor),
            "has_more": Serialization._BoolSerializer.serialize(value.hasMore),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListFolderResult {
            switch json {
                case .dictionary(let dict):
                    let entries = ArraySerializer(Files.MetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    let cursor = Serialization._StringSerializer.deserialize(dict["cursor"] ?? .null)
                    let hasMore = Serialization._BoolSerializer.deserialize(dict["has_more"] ?? .null)
                    return ListFolderResult(entries: entries, cursor: cursor, hasMore: hasMore)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListRevisionsArg struct
    */
    public class ListRevisionsArg: CustomStringConvertible {
        /// The path to the file you want to see the revisions of.
        public let path : String
        /// The maximum number of revision entries returned.
        public let limit : UInt64
        public init(path: String, limit: UInt64 = 10) {
            stringValidator(pattern: "/.*")(path)
            self.path = path
            comparableValidator(minValue: 1, maxValue: 100)(limit)
            self.limit = limit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsArgSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListRevisionsArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "limit": Serialization._UInt64Serializer.serialize(value.limit),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListRevisionsArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let limit = Serialization._UInt64Serializer.deserialize(dict["limit"] ?? .null)
                    return ListRevisionsArg(path: path, limit: limit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ListRevisionsError union
    */
    public enum ListRevisionsError: CustomStringConvertible {
        case path(Files.LookupError)
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsErrorSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListRevisionsError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ListRevisionsError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ListRevisionsError.path(v)
                        case "other":
                            return ListRevisionsError.other
                        default:
                            return ListRevisionsError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ListRevisionsResult struct
    */
    public class ListRevisionsResult: CustomStringConvertible {
        /// If the file is deleted.
        public let isDeleted : Bool
        /// The revisions for the file. Only non-delete revisions will show up here.
        public let entries : Array<Files.FileMetadata>
        public init(isDeleted: Bool, entries: Array<Files.FileMetadata>) {
            self.isDeleted = isDeleted
            self.entries = entries
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ListRevisionsResultSerializer().serialize(self)))"
        }
    }
    public class ListRevisionsResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ListRevisionsResult) -> JSON {
            let output = [ 
            "is_deleted": Serialization._BoolSerializer.serialize(value.isDeleted),
            "entries": ArraySerializer(Files.FileMetadataSerializer()).serialize(value.entries),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ListRevisionsResult {
            switch json {
                case .dictionary(let dict):
                    let isDeleted = Serialization._BoolSerializer.deserialize(dict["is_deleted"] ?? .null)
                    let entries = ArraySerializer(Files.FileMetadataSerializer()).deserialize(dict["entries"] ?? .null)
                    return ListRevisionsResult(isDeleted: isDeleted, entries: entries)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The LookupError union
    */
    public enum LookupError: CustomStringConvertible {
        case malformedPath(String?)
        /**
            There is nothing at the given path.
        */
        case notFound
        /**
            We were expecting a file, but the given path refers to something that isn't a file.
        */
        case notFile
        /**
            We were expecting a folder, but the given path refers to something that isn't a folder.
        */
        case notFolder
        /**
            The file cannot be transferred because the content is restricted.  For example, sometimes there are legal
            restrictions due to copyright claims.
        */
        case restrictedContent
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(LookupErrorSerializer().serialize(self)))"
        }
    }
    public class LookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: LookupError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .notFound:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .notFile:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_file")
                    return .dictionary(d)
                case .notFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_folder")
                    return .dictionary(d)
                case .restrictedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .str("restricted_content")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> LookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return LookupError.malformedPath(v)
                        case "not_found":
                            return LookupError.notFound
                        case "not_file":
                            return LookupError.notFile
                        case "not_folder":
                            return LookupError.notFolder
                        case "restricted_content":
                            return LookupError.restrictedContent
                        case "other":
                            return LookupError.other
                        default:
                            return LookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The MediaInfo union
    */
    public enum MediaInfo: CustomStringConvertible {
        /**
            Indicate the photo/video is still under processing and metadata is not available yet.
        */
        case pending
        /**
            The metadata for the photo/video.
        */
        case metadata(Files.MediaMetadata)
        public var description : String {
            return "\(prepareJSONForSerialization(MediaInfoSerializer().serialize(self)))"
        }
    }
    public class MediaInfoSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: MediaInfo) -> JSON {
            switch value {
                case .pending:
                    var d = [String : JSON]()
                    d[".tag"] = .str("pending")
                    return .dictionary(d)
                case .metadata(let arg):
                    var d = ["metadata": Files.MediaMetadataSerializer().serialize(arg)]
                    d[".tag"] = .str("metadata")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> MediaInfo {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "pending":
                            return MediaInfo.pending
                        case "metadata":
                            let v = Files.MediaMetadataSerializer().deserialize(d["metadata"] ?? .null)
                            return MediaInfo.metadata(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Metadata for a photo or video.
    */
    public class MediaMetadata: CustomStringConvertible {
        /// Dimension of the photo/video.
        public let dimensions : Files.Dimensions?
        /// The GPS coordinate of the photo/video.
        public let location : Files.GpsCoordinates?
        /// The timestamp when the photo/video is taken.
        public let timeTaken : Date?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil) {
            self.dimensions = dimensions
            self.location = location
            self.timeTaken = timeTaken
        }
        public var description : String {
            return "\(prepareJSONForSerialization(MediaMetadataSerializer().serialize(self)))"
        }
    }
    public class MediaMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: MediaMetadata) -> JSON {
            var output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            switch value {
                case let photo as Files.PhotoMetadata:
                    for (k,v) in Serialization.getFields(Files.PhotoMetadataSerializer().serialize(photo)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("photo")
                case let video as Files.VideoMetadata:
                    for (k,v) in Serialization.getFields(Files.VideoMetadataSerializer().serialize(video)) {
                        output[k] = v
                    }
                    output[".tag"] = .str("video")
                default: fatalError("Tried to serialize unexpected subtype")
            }
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> MediaMetadata {
            switch json {
                case .dictionary(let dict):
                    let tag = Serialization.getTag(dict)
                    switch tag {
                        case "photo":
                            return Files.PhotoMetadataSerializer().deserialize(json)
                        case "video":
                            return Files.VideoMetadataSerializer().deserialize(json)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a photo.
    */
    public class PhotoMetadata: Files.MediaMetadata {
        public override var description : String {
            return "\(prepareJSONForSerialization(PhotoMetadataSerializer().serialize(self)))"
        }
    }
    public class PhotoMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PhotoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> PhotoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    return PhotoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The PreviewArg struct
    */
    public class PreviewArg: CustomStringConvertible {
        /// The path of the file to preview.
        public let path : String
        /// Deprecated. Please specify revision in :field:'path' instead
        public let rev : String?
        public init(path: String, rev: String? = nil) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(path)
            self.path = path
            nullableValidator(stringValidator(minLength: 9, pattern: "[0-9a-f]+"))(rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewArgSerializer().serialize(self)))"
        }
    }
    public class PreviewArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PreviewArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": NullableSerializer(Serialization._StringSerializer).serialize(value.rev),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> PreviewArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = NullableSerializer(Serialization._StringSerializer).deserialize(dict["rev"] ?? .null)
                    return PreviewArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The PreviewError union
    */
    public enum PreviewError: CustomStringConvertible {
        /**
            An error occurs when downloading metadata for the file.
        */
        case path(Files.LookupError)
        /**
            This preview generation is still in progress and the file is not ready  for preview yet.
        */
        case inProgress
        /**
            The file extension is not supported preview generation.
        */
        case unsupportedExtension
        /**
            The file content is not supported for preview generation.
        */
        case unsupportedContent
        public var description : String {
            return "\(prepareJSONForSerialization(PreviewErrorSerializer().serialize(self)))"
        }
    }
    public class PreviewErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: PreviewError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .inProgress:
                    var d = [String : JSON]()
                    d[".tag"] = .str("in_progress")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedContent:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_content")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> PreviewError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return PreviewError.path(v)
                        case "in_progress":
                            return PreviewError.inProgress
                        case "unsupported_extension":
                            return PreviewError.unsupportedExtension
                        case "unsupported_content":
                            return PreviewError.unsupportedContent
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RelocationArg struct
    */
    public class RelocationArg: CustomStringConvertible {
        /// Path in the user's Dropbox to be copied or moved.
        public let fromPath : String
        /// Path in the user's Dropbox that is the destination.
        public let toPath : String
        public init(fromPath: String, toPath: String) {
            stringValidator(pattern: "/.*")(fromPath)
            self.fromPath = fromPath
            stringValidator(pattern: "/.*")(toPath)
            self.toPath = toPath
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationArgSerializer().serialize(self)))"
        }
    }
    public class RelocationArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RelocationArg) -> JSON {
            let output = [ 
            "from_path": Serialization._StringSerializer.serialize(value.fromPath),
            "to_path": Serialization._StringSerializer.serialize(value.toPath),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> RelocationArg {
            switch json {
                case .dictionary(let dict):
                    let fromPath = Serialization._StringSerializer.deserialize(dict["from_path"] ?? .null)
                    let toPath = Serialization._StringSerializer.deserialize(dict["to_path"] ?? .null)
                    return RelocationArg(fromPath: fromPath, toPath: toPath)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RelocationError union
    */
    public enum RelocationError: CustomStringConvertible {
        case fromLookup(Files.LookupError)
        case fromWrite(Files.WriteError)
        case to(Files.WriteError)
        /**
            Shared folders can't be copied.
        */
        case cantCopySharedFolder
        /**
            Your move operation would result in nested shared folders.  This is not allowed.
        */
        case cantNestSharedFolder
        /**
            You cannot move a folder into itself.
        */
        case cantMoveFolderIntoItself
        /**
            The operation would involve more than 10,000 files and folders.
        */
        case tooManyFiles
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RelocationErrorSerializer().serialize(self)))"
        }
    }
    public class RelocationErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RelocationError) -> JSON {
            switch value {
                case .fromLookup(let arg):
                    var d = ["from_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_lookup")
                    return .dictionary(d)
                case .fromWrite(let arg):
                    var d = ["from_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("from_write")
                    return .dictionary(d)
                case .to(let arg):
                    var d = ["to": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("to")
                    return .dictionary(d)
                case .cantCopySharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("cant_copy_shared_folder")
                    return .dictionary(d)
                case .cantNestSharedFolder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("cant_nest_shared_folder")
                    return .dictionary(d)
                case .cantMoveFolderIntoItself:
                    var d = [String : JSON]()
                    d[".tag"] = .str("cant_move_folder_into_itself")
                    return .dictionary(d)
                case .tooManyFiles:
                    var d = [String : JSON]()
                    d[".tag"] = .str("too_many_files")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> RelocationError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "from_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["from_lookup"] ?? .null)
                            return RelocationError.fromLookup(v)
                        case "from_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["from_write"] ?? .null)
                            return RelocationError.fromWrite(v)
                        case "to":
                            let v = Files.WriteErrorSerializer().deserialize(d["to"] ?? .null)
                            return RelocationError.to(v)
                        case "cant_copy_shared_folder":
                            return RelocationError.cantCopySharedFolder
                        case "cant_nest_shared_folder":
                            return RelocationError.cantNestSharedFolder
                        case "cant_move_folder_into_itself":
                            return RelocationError.cantMoveFolderIntoItself
                        case "too_many_files":
                            return RelocationError.tooManyFiles
                        case "other":
                            return RelocationError.other
                        default:
                            return RelocationError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The RestoreArg struct
    */
    public class RestoreArg: CustomStringConvertible {
        /// The path to the file you want to restore.
        public let path : String
        /// The revision to restore for the file.
        public let rev : String
        public init(path: String, rev: String) {
            stringValidator(pattern: "/.*")(path)
            self.path = path
            stringValidator(minLength: 9, pattern: "[0-9a-f]+")(rev)
            self.rev = rev
        }
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreArgSerializer().serialize(self)))"
        }
    }
    public class RestoreArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RestoreArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "rev": Serialization._StringSerializer.serialize(value.rev),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> RestoreArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let rev = Serialization._StringSerializer.deserialize(dict["rev"] ?? .null)
                    return RestoreArg(path: path, rev: rev)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The RestoreError union
    */
    public enum RestoreError: CustomStringConvertible {
        /**
            An error occurs when downloading metadata for the file.
        */
        case pathLookup(Files.LookupError)
        /**
            An error occurs when trying to restore the file to that path.
        */
        case pathWrite(Files.WriteError)
        /**
            The revision is invalid. It may point to a different file.
        */
        case invalidRevision
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(RestoreErrorSerializer().serialize(self)))"
        }
    }
    public class RestoreErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: RestoreError) -> JSON {
            switch value {
                case .pathLookup(let arg):
                    var d = ["path_lookup": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_lookup")
                    return .dictionary(d)
                case .pathWrite(let arg):
                    var d = ["path_write": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path_write")
                    return .dictionary(d)
                case .invalidRevision:
                    var d = [String : JSON]()
                    d[".tag"] = .str("invalid_revision")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> RestoreError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path_lookup":
                            let v = Files.LookupErrorSerializer().deserialize(d["path_lookup"] ?? .null)
                            return RestoreError.pathLookup(v)
                        case "path_write":
                            let v = Files.WriteErrorSerializer().deserialize(d["path_write"] ?? .null)
                            return RestoreError.pathWrite(v)
                        case "invalid_revision":
                            return RestoreError.invalidRevision
                        case "other":
                            return RestoreError.other
                        default:
                            return RestoreError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SearchArg struct
    */
    public class SearchArg: CustomStringConvertible {
        /// The path in the user's Dropbox to search. Should probably be a folder.
        public let path : String
        /// The string to search for. The search string is split on spaces into multiple tokens. For file name
        /// searching, the last token is used for prefix matching (i.e. "bat c" matches "bat cave" but not "batman
        /// car").
        public let query : String
        /// The starting index within the search results (used for paging).
        public let start : UInt64
        /// The maximum number of search results to return.
        public let maxResults : UInt64
        /// The search mode (filename, filename_and_content, or deleted_filename). Note that searching file content is
        /// only available for Dropbox Business accounts.
        public let mode : Files.SearchMode
        public init(path: String, query: String, start: UInt64 = 0, maxResults: UInt64 = 100, mode: Files.SearchMode = .filename) {
            stringValidator(pattern: "(/.*)?")(path)
            self.path = path
            stringValidator()(query)
            self.query = query
            comparableValidator()(start)
            self.start = start
            comparableValidator(minValue: 1, maxValue: 1000)(maxResults)
            self.maxResults = maxResults
            self.mode = mode
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchArgSerializer().serialize(self)))"
        }
    }
    public class SearchArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "query": Serialization._StringSerializer.serialize(value.query),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            "max_results": Serialization._UInt64Serializer.serialize(value.maxResults),
            "mode": Files.SearchModeSerializer().serialize(value.mode),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SearchArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let query = Serialization._StringSerializer.deserialize(dict["query"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    let maxResults = Serialization._UInt64Serializer.deserialize(dict["max_results"] ?? .null)
                    let mode = Files.SearchModeSerializer().deserialize(dict["mode"] ?? .null)
                    return SearchArg(path: path, query: query, start: start, maxResults: maxResults, mode: mode)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The SearchError union
    */
    public enum SearchError: CustomStringConvertible {
        case path(Files.LookupError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(SearchErrorSerializer().serialize(self)))"
        }
    }
    public class SearchErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SearchError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return SearchError.path(v)
                        case "other":
                            return SearchError.other
                        default:
                            return SearchError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SearchMatch struct
    */
    public class SearchMatch: CustomStringConvertible {
        /// The type of the match.
        public let matchType : Files.SearchMatchType
        /// The metadata for the matched file or folder.
        public let metadata : Files.Metadata
        public init(matchType: Files.SearchMatchType, metadata: Files.Metadata) {
            self.matchType = matchType
            self.metadata = metadata
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchSerializer().serialize(self)))"
        }
    }
    public class SearchMatchSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchMatch) -> JSON {
            let output = [ 
            "match_type": Files.SearchMatchTypeSerializer().serialize(value.matchType),
            "metadata": Files.MetadataSerializer().serialize(value.metadata),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SearchMatch {
            switch json {
                case .dictionary(let dict):
                    let matchType = Files.SearchMatchTypeSerializer().deserialize(dict["match_type"] ?? .null)
                    let metadata = Files.MetadataSerializer().deserialize(dict["metadata"] ?? .null)
                    return SearchMatch(matchType: matchType, metadata: metadata)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Indicates what type of match was found for a given item.
    */
    public enum SearchMatchType: CustomStringConvertible {
        /**
            This item was matched on its file or folder name.
        */
        case filename
        /**
            This item was matched based on its file contents.
        */
        case content
        /**
            This item was matched based on both its contents and its file name.
        */
        case both
        public var description : String {
            return "\(prepareJSONForSerialization(SearchMatchTypeSerializer().serialize(self)))"
        }
    }
    public class SearchMatchTypeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchMatchType) -> JSON {
            switch value {
                case .filename:
                    var d = [String : JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .content:
                    var d = [String : JSON]()
                    d[".tag"] = .str("content")
                    return .dictionary(d)
                case .both:
                    var d = [String : JSON]()
                    d[".tag"] = .str("both")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SearchMatchType {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMatchType.filename
                        case "content":
                            return SearchMatchType.content
                        case "both":
                            return SearchMatchType.both
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SearchMode union
    */
    public enum SearchMode: CustomStringConvertible {
        /**
            Search file and folder names.
        */
        case filename
        /**
            Search file and folder names as well as file contents.
        */
        case filenameAndContent
        /**
            Search for deleted file and folder names.
        */
        case deletedFilename
        public var description : String {
            return "\(prepareJSONForSerialization(SearchModeSerializer().serialize(self)))"
        }
    }
    public class SearchModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchMode) -> JSON {
            switch value {
                case .filename:
                    var d = [String : JSON]()
                    d[".tag"] = .str("filename")
                    return .dictionary(d)
                case .filenameAndContent:
                    var d = [String : JSON]()
                    d[".tag"] = .str("filename_and_content")
                    return .dictionary(d)
                case .deletedFilename:
                    var d = [String : JSON]()
                    d[".tag"] = .str("deleted_filename")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> SearchMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "filename":
                            return SearchMode.filename
                        case "filename_and_content":
                            return SearchMode.filenameAndContent
                        case "deleted_filename":
                            return SearchMode.deletedFilename
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The SearchResult struct
    */
    public class SearchResult: CustomStringConvertible {
        /// A list (possibly empty) of matches for the query.
        public let matches : Array<Files.SearchMatch>
        /// Used for paging. If true, indicates there is another page of results available that can be fetched by
        /// calling search again.
        public let more : Bool
        /// Used for paging. Value to set the start argument to when calling search to fetch the next page of results.
        public let start : UInt64
        public init(matches: Array<Files.SearchMatch>, more: Bool, start: UInt64) {
            self.matches = matches
            self.more = more
            comparableValidator()(start)
            self.start = start
        }
        public var description : String {
            return "\(prepareJSONForSerialization(SearchResultSerializer().serialize(self)))"
        }
    }
    public class SearchResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: SearchResult) -> JSON {
            let output = [ 
            "matches": ArraySerializer(Files.SearchMatchSerializer()).serialize(value.matches),
            "more": Serialization._BoolSerializer.serialize(value.more),
            "start": Serialization._UInt64Serializer.serialize(value.start),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> SearchResult {
            switch json {
                case .dictionary(let dict):
                    let matches = ArraySerializer(Files.SearchMatchSerializer()).deserialize(dict["matches"] ?? .null)
                    let more = Serialization._BoolSerializer.deserialize(dict["more"] ?? .null)
                    let start = Serialization._UInt64Serializer.deserialize(dict["start"] ?? .null)
                    return SearchResult(matches: matches, more: more, start: start)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ThumbnailArg struct
    */
    public class ThumbnailArg: CustomStringConvertible {
        /// The path to the image file you want to thumbnail.
        public let path : String
        /// The format for the thumbnail image, jpeg (default) or png. For  images that are photos, jpeg should be
        /// preferred, while png is  better for screenshots and digital arts.
        public let format : Files.ThumbnailFormat
        /// The size for the thumbnail image.
        public let size : Files.ThumbnailSize
        public init(path: String, format: Files.ThumbnailFormat = .jpeg, size: Files.ThumbnailSize = .w64h64) {
            stringValidator(pattern: "((/|id:).*)|(rev:[0-9a-f]{9,})")(path)
            self.path = path
            self.format = format
            self.size = size
        }
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailArgSerializer().serialize(self)))"
        }
    }
    public class ThumbnailArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailArg) -> JSON {
            let output = [ 
            "path": Serialization._StringSerializer.serialize(value.path),
            "format": Files.ThumbnailFormatSerializer().serialize(value.format),
            "size": Files.ThumbnailSizeSerializer().serialize(value.size),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> ThumbnailArg {
            switch json {
                case .dictionary(let dict):
                    let path = Serialization._StringSerializer.deserialize(dict["path"] ?? .null)
                    let format = Files.ThumbnailFormatSerializer().deserialize(dict["format"] ?? .null)
                    let size = Files.ThumbnailSizeSerializer().deserialize(dict["size"] ?? .null)
                    return ThumbnailArg(path: path, format: format, size: size)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The ThumbnailError union
    */
    public enum ThumbnailError: CustomStringConvertible {
        /**
            An error occurs when downloading metadata for the image.
        */
        case path(Files.LookupError)
        /**
            The file extension doesn't allow conversion to a thumbnail.
        */
        case unsupportedExtension
        /**
            The image cannot be converted to a thumbnail.
        */
        case unsupportedImage
        /**
            An error occurs during thumbnail conversion.
        */
        case conversionError
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailErrorSerializer().serialize(self)))"
        }
    }
    public class ThumbnailErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = ["path": Files.LookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .unsupportedExtension:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_extension")
                    return .dictionary(d)
                case .unsupportedImage:
                    var d = [String : JSON]()
                    d[".tag"] = .str("unsupported_image")
                    return .dictionary(d)
                case .conversionError:
                    var d = [String : JSON]()
                    d[".tag"] = .str("conversion_error")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ThumbnailError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.LookupErrorSerializer().deserialize(d["path"] ?? .null)
                            return ThumbnailError.path(v)
                        case "unsupported_extension":
                            return ThumbnailError.unsupportedExtension
                        case "unsupported_image":
                            return ThumbnailError.unsupportedImage
                        case "conversion_error":
                            return ThumbnailError.conversionError
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ThumbnailFormat union
    */
    public enum ThumbnailFormat: CustomStringConvertible {
        case jpeg
        case png
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailFormatSerializer().serialize(self)))"
        }
    }
    public class ThumbnailFormatSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailFormat) -> JSON {
            switch value {
                case .jpeg:
                    var d = [String : JSON]()
                    d[".tag"] = .str("jpeg")
                    return .dictionary(d)
                case .png:
                    var d = [String : JSON]()
                    d[".tag"] = .str("png")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ThumbnailFormat {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "jpeg":
                            return ThumbnailFormat.jpeg
                        case "png":
                            return ThumbnailFormat.png
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The ThumbnailSize union
    */
    public enum ThumbnailSize: CustomStringConvertible {
        /**
            32 by 32 px.
        */
        case w32h32
        /**
            64 by 64 px.
        */
        case w64h64
        /**
            128 by 128 px.
        */
        case w128h128
        /**
            640 by 480 px.
        */
        case w640h480
        /**
            1024 by 768
        */
        case w1024h768
        public var description : String {
            return "\(prepareJSONForSerialization(ThumbnailSizeSerializer().serialize(self)))"
        }
    }
    public class ThumbnailSizeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: ThumbnailSize) -> JSON {
            switch value {
                case .w32h32:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w32h32")
                    return .dictionary(d)
                case .w64h64:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w64h64")
                    return .dictionary(d)
                case .w128h128:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w128h128")
                    return .dictionary(d)
                case .w640h480:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w640h480")
                    return .dictionary(d)
                case .w1024h768:
                    var d = [String : JSON]()
                    d[".tag"] = .str("w1024h768")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> ThumbnailSize {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "w32h32":
                            return ThumbnailSize.w32h32
                        case "w64h64":
                            return ThumbnailSize.w64h64
                        case "w128h128":
                            return ThumbnailSize.w128h128
                        case "w640h480":
                            return ThumbnailSize.w640h480
                        case "w1024h768":
                            return ThumbnailSize.w1024h768
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadError union
    */
    public enum UploadError: CustomStringConvertible {
        /**
            Unable to save the uploaded contents to a file.
        */
        case path(Files.UploadWriteFailed)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadErrorSerializer().serialize(self)))"
        }
    }
    public class UploadErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadError) -> JSON {
            switch value {
                case .path(let arg):
                    var d = Serialization.getFields(Files.UploadWriteFailedSerializer().serialize(arg))
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "path":
                            let v = Files.UploadWriteFailedSerializer().deserialize(json)
                            return UploadError.path(v)
                        case "other":
                            return UploadError.other
                        default:
                            return UploadError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadSessionCursor struct
    */
    public class UploadSessionCursor: CustomStringConvertible {
        /// The upload session ID (returned by uploadSessionStart).
        public let sessionId : String
        /// The amount of data that has been uploaded so far. We use this to make sure upload data isn't lost or
        /// duplicated in the event of a network error.
        public let offset : UInt64
        public init(sessionId: String, offset: UInt64) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
            comparableValidator()(offset)
            self.offset = offset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionCursorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionCursorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionCursor) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            "offset": Serialization._UInt64Serializer.serialize(value.offset),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionCursor {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    let offset = Serialization._UInt64Serializer.deserialize(dict["offset"] ?? .null)
                    return UploadSessionCursor(sessionId: sessionId, offset: offset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadSessionFinishArg struct
    */
    public class UploadSessionFinishArg: CustomStringConvertible {
        /// Contains the upload session ID and the offset.
        public let cursor : Files.UploadSessionCursor
        /// Contains the path and other optional modifiers for the commit.
        public let commit : Files.CommitInfo
        public init(cursor: Files.UploadSessionCursor, commit: Files.CommitInfo) {
            self.cursor = cursor
            self.commit = commit
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishArgSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishArgSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishArg) -> JSON {
            let output = [ 
            "cursor": Files.UploadSessionCursorSerializer().serialize(value.cursor),
            "commit": Files.CommitInfoSerializer().serialize(value.commit),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishArg {
            switch json {
                case .dictionary(let dict):
                    let cursor = Files.UploadSessionCursorSerializer().deserialize(dict["cursor"] ?? .null)
                    let commit = Files.CommitInfoSerializer().deserialize(dict["commit"] ?? .null)
                    return UploadSessionFinishArg(cursor: cursor, commit: commit)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadSessionFinishError union
    */
    public enum UploadSessionFinishError: CustomStringConvertible {
        /**
            The session arguments are incorrect; the value explains the reason.
        */
        case lookupFailed(Files.UploadSessionLookupError)
        /**
            Unable to save the uploaded contents to a file.
        */
        case path(Files.WriteError)
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionFinishErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionFinishErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionFinishError) -> JSON {
            switch value {
                case .lookupFailed(let arg):
                    var d = ["lookup_failed": Files.UploadSessionLookupErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("lookup_failed")
                    return .dictionary(d)
                case .path(let arg):
                    var d = ["path": Files.WriteErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("path")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadSessionFinishError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "lookup_failed":
                            let v = Files.UploadSessionLookupErrorSerializer().deserialize(d["lookup_failed"] ?? .null)
                            return UploadSessionFinishError.lookupFailed(v)
                        case "path":
                            let v = Files.WriteErrorSerializer().deserialize(d["path"] ?? .null)
                            return UploadSessionFinishError.path(v)
                        case "other":
                            return UploadSessionFinishError.other
                        default:
                            return UploadSessionFinishError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadSessionLookupError union
    */
    public enum UploadSessionLookupError: CustomStringConvertible {
        /**
            The upload session id was not found.
        */
        case notFound
        /**
            The specified offset was incorrect. See the value for the correct offset. (This error may occur when a
            previous request was received and processed successfully but the client did not receive the response, e.g.
            due to a network error.)
        */
        case incorrectOffset(Files.UploadSessionOffsetError)
        /**
            You are attempting to append data to an upload session that has alread been closed (i.e. committed).
        */
        case closed
        /**
            An unspecified error.
        */
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionLookupErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionLookupErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionLookupError) -> JSON {
            switch value {
                case .notFound:
                    var d = [String : JSON]()
                    d[".tag"] = .str("not_found")
                    return .dictionary(d)
                case .incorrectOffset(let arg):
                    var d = Serialization.getFields(Files.UploadSessionOffsetErrorSerializer().serialize(arg))
                    d[".tag"] = .str("incorrect_offset")
                    return .dictionary(d)
                case .closed:
                    var d = [String : JSON]()
                    d[".tag"] = .str("closed")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> UploadSessionLookupError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "not_found":
                            return UploadSessionLookupError.notFound
                        case "incorrect_offset":
                            let v = Files.UploadSessionOffsetErrorSerializer().deserialize(json)
                            return UploadSessionLookupError.incorrectOffset(v)
                        case "closed":
                            return UploadSessionLookupError.closed
                        case "other":
                            return UploadSessionLookupError.other
                        default:
                            return UploadSessionLookupError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The UploadSessionOffsetError struct
    */
    public class UploadSessionOffsetError: CustomStringConvertible {
        /// The offset up to which data has been collected.
        public let correctOffset : UInt64
        public init(correctOffset: UInt64) {
            comparableValidator()(correctOffset)
            self.correctOffset = correctOffset
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionOffsetErrorSerializer().serialize(self)))"
        }
    }
    public class UploadSessionOffsetErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionOffsetError) -> JSON {
            let output = [ 
            "correct_offset": Serialization._UInt64Serializer.serialize(value.correctOffset),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionOffsetError {
            switch json {
                case .dictionary(let dict):
                    let correctOffset = Serialization._UInt64Serializer.deserialize(dict["correct_offset"] ?? .null)
                    return UploadSessionOffsetError(correctOffset: correctOffset)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadSessionStartResult struct
    */
    public class UploadSessionStartResult: CustomStringConvertible {
        /// A unique identifier for the upload session. Pass this to uploadSessionAppend and uploadSessionFinish.
        public let sessionId : String
        public init(sessionId: String) {
            stringValidator()(sessionId)
            self.sessionId = sessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadSessionStartResultSerializer().serialize(self)))"
        }
    }
    public class UploadSessionStartResultSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadSessionStartResult) -> JSON {
            let output = [ 
            "session_id": Serialization._StringSerializer.serialize(value.sessionId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadSessionStartResult {
            switch json {
                case .dictionary(let dict):
                    let sessionId = Serialization._StringSerializer.deserialize(dict["session_id"] ?? .null)
                    return UploadSessionStartResult(sessionId: sessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The UploadWriteFailed struct
    */
    public class UploadWriteFailed: CustomStringConvertible {
        /// The reason why the file couldn't be saved.
        public let reason : Files.WriteError
        /// The upload session ID; this may be used to retry the commit.
        public let uploadSessionId : String
        public init(reason: Files.WriteError, uploadSessionId: String) {
            self.reason = reason
            stringValidator()(uploadSessionId)
            self.uploadSessionId = uploadSessionId
        }
        public var description : String {
            return "\(prepareJSONForSerialization(UploadWriteFailedSerializer().serialize(self)))"
        }
    }
    public class UploadWriteFailedSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: UploadWriteFailed) -> JSON {
            let output = [ 
            "reason": Files.WriteErrorSerializer().serialize(value.reason),
            "upload_session_id": Serialization._StringSerializer.serialize(value.uploadSessionId),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> UploadWriteFailed {
            switch json {
                case .dictionary(let dict):
                    let reason = Files.WriteErrorSerializer().deserialize(dict["reason"] ?? .null)
                    let uploadSessionId = Serialization._StringSerializer.deserialize(dict["upload_session_id"] ?? .null)
                    return UploadWriteFailed(reason: reason, uploadSessionId: uploadSessionId)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        Metadata for a video.
    */
    public class VideoMetadata: Files.MediaMetadata {
        /// The duration of the video in milliseconds.
        public let duration : UInt64?
        public init(dimensions: Files.Dimensions? = nil, location: Files.GpsCoordinates? = nil, timeTaken: Date? = nil, duration: UInt64? = nil) {
            nullableValidator(comparableValidator())(duration)
            self.duration = duration
            super.init(dimensions: dimensions, location: location, timeTaken: timeTaken)
        }
        public override var description : String {
            return "\(prepareJSONForSerialization(VideoMetadataSerializer().serialize(self)))"
        }
    }
    public class VideoMetadataSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: VideoMetadata) -> JSON {
            let output = [ 
            "dimensions": NullableSerializer(Files.DimensionsSerializer()).serialize(value.dimensions),
            "location": NullableSerializer(Files.GpsCoordinatesSerializer()).serialize(value.location),
            "time_taken": NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).serialize(value.timeTaken),
            "duration": NullableSerializer(Serialization._UInt64Serializer).serialize(value.duration),
            ]
            return .dictionary(output)
        }
        public func deserialize(_ json: JSON) -> VideoMetadata {
            switch json {
                case .dictionary(let dict):
                    let dimensions = NullableSerializer(Files.DimensionsSerializer()).deserialize(dict["dimensions"] ?? .null)
                    let location = NullableSerializer(Files.GpsCoordinatesSerializer()).deserialize(dict["location"] ?? .null)
                    let timeTaken = NullableSerializer(NSDateSerializer("%Y-%m-%dT%H:%M:%SZ")).deserialize(dict["time_taken"] ?? .null)
                    let duration = NullableSerializer(Serialization._UInt64Serializer).deserialize(dict["duration"] ?? .null)
                    return VideoMetadata(dimensions: dimensions, location: location, timeTaken: timeTaken, duration: duration)
                default:
                    fatalError("Type error deserializing")
            }
        }
    }
    /**
        The WriteConflictError union
    */
    public enum WriteConflictError: CustomStringConvertible {
        /**
            There's a file in the way.
        */
        case file
        /**
            There's a folder in the way.
        */
        case folder
        /**
            There's a file at an ancestor path, so we couldn't create the required parent folders.
        */
        case fileAncestor
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(WriteConflictErrorSerializer().serialize(self)))"
        }
    }
    public class WriteConflictErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: WriteConflictError) -> JSON {
            switch value {
                case .file:
                    var d = [String : JSON]()
                    d[".tag"] = .str("file")
                    return .dictionary(d)
                case .folder:
                    var d = [String : JSON]()
                    d[".tag"] = .str("folder")
                    return .dictionary(d)
                case .fileAncestor:
                    var d = [String : JSON]()
                    d[".tag"] = .str("file_ancestor")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> WriteConflictError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "file":
                            return WriteConflictError.file
                        case "folder":
                            return WriteConflictError.folder
                        case "file_ancestor":
                            return WriteConflictError.fileAncestor
                        case "other":
                            return WriteConflictError.other
                        default:
                            return WriteConflictError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        The WriteError union
    */
    public enum WriteError: CustomStringConvertible {
        case malformedPath(String?)
        /**
            Couldn't write to the target path because there was something in the way.
        */
        case conflict(Files.WriteConflictError)
        /**
            The user doesn't have permissions to write to the target location.
        */
        case noWritePermission
        /**
            The user doesn't have enough available space (bytes) to write more data.
        */
        case insufficientSpace
        /**
            Dropbox will not save the file or folder because of its name.
        */
        case disallowedName
        case other
        public var description : String {
            return "\(prepareJSONForSerialization(WriteErrorSerializer().serialize(self)))"
        }
    }
    public class WriteErrorSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: WriteError) -> JSON {
            switch value {
                case .malformedPath(let arg):
                    var d = ["malformed_path": NullableSerializer(Serialization._StringSerializer).serialize(arg)]
                    d[".tag"] = .str("malformed_path")
                    return .dictionary(d)
                case .conflict(let arg):
                    var d = ["conflict": Files.WriteConflictErrorSerializer().serialize(arg)]
                    d[".tag"] = .str("conflict")
                    return .dictionary(d)
                case .noWritePermission:
                    var d = [String : JSON]()
                    d[".tag"] = .str("no_write_permission")
                    return .dictionary(d)
                case .insufficientSpace:
                    var d = [String : JSON]()
                    d[".tag"] = .str("insufficient_space")
                    return .dictionary(d)
                case .disallowedName:
                    var d = [String : JSON]()
                    d[".tag"] = .str("disallowed_name")
                    return .dictionary(d)
                case .other:
                    var d = [String : JSON]()
                    d[".tag"] = .str("other")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> WriteError {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "malformed_path":
                            let v = NullableSerializer(Serialization._StringSerializer).deserialize(d["malformed_path"] ?? .null)
                            return WriteError.malformedPath(v)
                        case "conflict":
                            let v = Files.WriteConflictErrorSerializer().deserialize(d["conflict"] ?? .null)
                            return WriteError.conflict(v)
                        case "no_write_permission":
                            return WriteError.noWritePermission
                        case "insufficient_space":
                            return WriteError.insufficientSpace
                        case "disallowed_name":
                            return WriteError.disallowedName
                        case "other":
                            return WriteError.other
                        default:
                            return WriteError.other
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
    /**
        Your intent when writing a file to some path. This is used to determine what constitutes a conflict and what the
        autorename strategy is. In some situations, the conflict behavior is identical: (a) If the target path doesn't
        contain anything, the file is always written; no conflict. (b) If the target path contains a folder, it's always
        a conflict. (c) If the target path contains a file with identical contents, nothing gets written; no conflict.
        The conflict checking differs in the case where there's a file at the target path with contents different from
        the contents you're trying to write.
    */
    public enum WriteMode: CustomStringConvertible {
        /**
            Never overwrite the existing file. The autorename strategy is to append a number to the file name. For
            example, "document.txt" might become "document (2).txt".
        */
        case add
        /**
            Always overwrite the existing file. The autorename strategy is the same as it is for add.
        */
        case overwrite
        /**
            Overwrite if the given "rev" matches the existing file's "rev". The autorename strategy is to append the
            string "conflicted copy" to the file name. For example, "document.txt" might become "document (conflicted
            copy).txt" or "document (Panda's conflicted copy).txt".
        */
        case update(String)
        public var description : String {
            return "\(prepareJSONForSerialization(WriteModeSerializer().serialize(self)))"
        }
    }
    public class WriteModeSerializer: JSONSerializer {
        public init() { }
        public func serialize(_ value: WriteMode) -> JSON {
            switch value {
                case .add:
                    var d = [String : JSON]()
                    d[".tag"] = .str("add")
                    return .dictionary(d)
                case .overwrite:
                    var d = [String : JSON]()
                    d[".tag"] = .str("overwrite")
                    return .dictionary(d)
                case .update(let arg):
                    var d = ["update": Serialization._StringSerializer.serialize(arg)]
                    d[".tag"] = .str("update")
                    return .dictionary(d)
            }
        }
        public func deserialize(_ json: JSON) -> WriteMode {
            switch json {
                case .dictionary(let d):
                    let tag = Serialization.getTag(d)
                    switch tag {
                        case "add":
                            return WriteMode.add
                        case "overwrite":
                            return WriteMode.overwrite
                        case "update":
                            let v = Serialization._StringSerializer.deserialize(d["update"] ?? .null)
                            return WriteMode.update(v)
                        default:
                            fatalError("Unknown tag \(tag)")
                    }
                default:
                    fatalError("Failed to deserialize")
            }
        }
    }
}
